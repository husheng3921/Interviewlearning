# TCP可靠传输的实现

## 字节为单位的滑动窗口
![](img/TCP首部.png)
> TCP首部中窗口字段占2字节，窗口值[0, 2^16-1]之间的整数。指出了接收方允许对方发送的数据量，动态变化  

![](/计算机网络/img/TCP窗口-1.png)
* 发送窗口的数据状态种类：
a.已发送已确认，b.已发送但未确认，c.允许发送但尚未发送，d.不允许发送
* 接收窗口数据种类：
a.已发送确认交付，b.允许接受未发送确认，c.不允许接收

> P3-P1=A的发送窗口  
> P2-P1=已发送尚未确认  
> P3-P2=允许发送尚未发送(可用窗口或有效窗口)  
虽然5-16中，32、33未按序收到，但是B只能按序收到的数据中的最高序号给出确认，即发送确认号31。  

B现在收到了序号为31的数据，，把31-33都交付，删除这些数据，接收窗口向前移动3个序号如图5-17所示,同时给A发送确认号34，窗口大小20。  
![](img/TCP窗口-2.png)  
A收到B的确认号后，窗口向前移动三个序号，指针P2不动，A的可用窗口变大。A继续发送数据42-53后，指针P2与P3重合，P1未移动，即未新增确认号；如图5-18；  
![](img/TCP窗口-3.png)  
此时A窗口序号已用完，停止发送。A等待B确认，假若B发送了确认，如果没有收到确认，会超时重传这部分数据。  
实际上，字节流是写入TCP的缓存中，<strong>缓存大于窗口</strong>，进行发送和接收。如图5-19  
![](img/TCP窗口-4.png)  
>发送缓存暂时存放的是：  
(1)已发送暂未确认  
(2)TCP准备发送的数据  
接收缓存：  
(1)按序到达、但尚未被应用程序接收的数据；  
(2)未按序到达的数据。  
>

### 小结：

* A发送窗口是由B发送窗口确定，并不总是一样大的；根据网络拥塞调控。
* 不按序到达的数据处理，先临时缓存在接收窗口中,等缺少的字节收到后，按序交付上层应用。
* TCP接收方有累积确认的功能，减小传输开销，在合适的时候发送确认，也可以在自己发送数据时捎带确认信息。
* TCP是全双工通信，每一方都有自己的发送和接收窗口。

## 超时重传

RTT 报文发出到收到确认的时间差。  
RTTs 是一个加权平均往返时间。每次重采样RTT样本时间，计算新的RTTs:  
新的RTTs = (1-$\alpha$)*(旧的RTTs)+$\alpha$*(新的RTT样本)  
超时重传时间RTO略大于RTTs;  

## 选择确认SACK

报文段无差错，只是未按序号，中间缺少一些序号，能否让发送方只传缺少的数据，而不重传已到达接收方的数据。选择SACK可以解决，但是得在TCP头部加上SACK，指明边界，双方事先商量好。目前暂未支持。

## 总结

* 滑动窗口是以字节为单位，基于缓存区(大小大于滑动窗口)，发送方和接收方商量窗口大小，发送方不能大于接收方窗口大小。
* 发送方数据状态类型有四种：发送已确认、发送未确认、准备发送、不允许发送，中间两种构成滑动窗口大小，也是缓存中的数据；接收方数据状态类型有三种：接收已确认、允许接收未确认、未接收，允许接收构成窗口大小，缓存中存放已接收已确认但未交付应用程序，未按序到达的数据。
* 超时重传时间RTO，涉及对RTT采样加权计算。
* 选择确认SACK机制只传送缺少的序号数据，不用重传未按序已正确到达的数据，目前暂未支持。
