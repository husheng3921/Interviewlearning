# TCP 连接与释放

连接过程中三个问题：
* 要使每一方能够确知对方的存在。
* 要允许双方协商一些参数(窗口最大值、等)
* 能够对运输实体资源进行分配

## TCP连接三次握手
客户端与服务端需要交换三个报文段。俗称三次握手
![](/计算机网络/img/TCP三次-1.png)
* A客户端首先创建传输控制块TCB，向B发送请求报文段，首部中<strong>同步位=1;同时初始序列号seq=x</strong>。此时A进入<strong>SYN-SENT状态</strong>.
* B收到A的请求报文，同意连接，需要发送确认；确认报文段首部中<strong>ACK=1,SYN=1,确认号ack=x+1;同时B发送一个自己的序号seq=y</strong>;B进入<strong>SYN-RCVD</strong>.
* A收到B的确认后，需向B发送已收到的确认。确认报文<strong>ACK=1;确认号ack=y+1;自己的序号seq=x+1</strong>;这时A进入<strong>ESTABLISHED</strong>。
* B收到A的确认后，也进入ESTABLISHED。

> 前两次握手就是为了让双方都确认对方可以进行连接了。B的第一次确认，让A知道B同意建立连接；A的第一次确认让B知道A收到B可以建立连接的报文；若没收到A的确认报文，B会重传。  
>> <strong>A为啥最后要发一次确认？</strong>  
> 防止已失效的连接请求报文段突然传送到B，产生错误；即A发出的一个请求连接报文段在网络中长时间滞留，A未收到B的确认，重传请求连接，建立连接后，释放请求，此时B收到了第一个延误的请求连接，则会认为A发送新的请求连接，B发送同意了连接的确认报文，假若没有第三次确认，B就直接建立了连接，而A并不理睬B的确认，也不会向B发送出，造成B一直等待，浪费资源。

## TCP的连接与释放

![](/计算机网络/img/TCP四次-1.png)
* A主动申请关闭,停止再发送数据，释放报文首部<strong>FIN=1，序号seq=u</strong>,A进入FIN-WAIT-1状态。
* B收到连接释放报文段发出确认，确认号<strong>ACK=1,ack=u+1;自己的序号seq=v</strong>；B就进入CLOSE-WAIT状态。TCP服务进程通知应用进程A到B的方向连接就释放了，TCP处于半关闭状态。A没有数据发送给B，但是B可能有数据继续发送给A。
* A收到了B的确认后，进入FIN-WAIT-2状态，等待B连接释放报文段。
* 若B已经没有数据发送给A了，则通知应用进程释放；B的释放报文段首部<strong>FIN=1;ACK=1;seq=w;ack=u+1;</strong>B进入LAST-ACK状态，等待A的确认。
* A收到B的释放报文，必须发出确认报文，<strong>ACK=1;seq=u+1;ack=w+1;</strong>,此时A进入TIME-WAIT状态，若B收到确认报文后则进入关闭；现在TCP还没有释放，经过时间等待计时器设置的2MSL(最长报文段寿命，2分钟，实际设置30秒)，A才进入关闭。

> <strong>为什么要经过2MSL的时间</strong>
> 1、确保A发送的最后一个ACK报文能到达B；这个报文有可能丢失，B会重传确认报文，A在2MSL时间内重传一次确认，同时重启2MSL计时器。最后AB都能正常进入关闭状态。
> 2、防止已经失效的请求报文段出现在连接中，经过A最后一个ACK报文后，再经过2MSL时间，使得本次连接中产生的所有报文段都从网络中消失。

### 保活计时器(keepalive timer)

假如客户端与服务端建立了TCP连接，但是由于客户端突然出现故障；服务器不再受到客户端的数据，却要一直等待；因此使用<strong>保活计时器</strong>，服务器每次收到客户端的数据就重新设置保活计时器，时间为2小时；两小时没有收到客户端数据，服务器发送探测报文段，每隔75秒发送一次，一连发送10个探测报文无反应则服务器认为客户端出了故障，关闭这个连接。
