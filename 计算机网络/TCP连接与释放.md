# TCP 连接与释放

连接过程中三个问题：
* 要使每一方能够确知对方的存在。
* 要允许双方协商一些参数(窗口最大值、等)
* 能够对运输实体资源进行分配

## TCP连接三次握手
客户端与服务端需要交换三个报文段。俗称三次握手
![](/计算机网络/img/TCP三次-1.png)
* A客户端首先创建传输控制块TCB，向B发送请求报文段，首部中<strong>同步位=1;同时初始序列号seq=x</strong>。此时A进入<strong>SYN-SENT状态</strong>.
* B收到A的请求报文，同意连接，需要发送确认；确认报文段首部中<strong>ACK=1,SYN=1,确认号ack=x+1;同时B发送一个自己的序号seq=y</strong>;B进入<strong>SYN-RCVD</strong>.
* A收到B的确认后，需向B发送已收到的确认。确认报文<strong>ACK=1;确认号ack=y+1;自己的序号seq=x+1</strong>;这时A进入<strong>ESTABLISHED</strong>。
* B收到A的确认后，也进入ESTABLISHED。

> 前两次握手就是为了让双方都确认对方可以进行连接了。B的第一次确认，让A知道B同意建立连接；A的第一次确认让B知道A收到B可以建立连接的报文；若没收到A的确认报文，B会重传。  
>> <strong>A为啥最后要发一次确认？</strong>  
> 防止已失效的连接请求报文段突然传送到B，产生错误；即A发出的一个请求连接报文段在网络中长时间滞留，A未收到B的确认，重传请求连接，建立连接后，释放请求，此时B收到了第一个延误的请求连接，则会认为A发送新的请求连接，B发送同意了连接的确认报文，假若没有第三次确认，B就直接建立了连接，而A并不理睬B的确认，也不会向B发送出，造成B一直等待，浪费资源。  
> 
>><strong>三次握手过程中可以携带数据吗</strong>  
>第三次握手的时候，可以携带。前两次握手不能携带数据。  
如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。  
第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

## TCP的连接释放

![](/计算机网络/img/TCP四次-1.png)
* A主动申请关闭,停止再发送数据，释放报文首部<strong>FIN=1，序号seq=u</strong>,A进入FIN-WAIT-1状态。
* B收到连接释放报文段发出确认，确认号<strong>ACK=1,ack=u+1;自己的序号seq=v</strong>；B就进入CLOSE-WAIT状态。TCP服务进程通知应用进程A到B的方向连接就释放了，TCP处于半关闭状态。A没有数据发送给B，但是B可能有数据继续发送给A。
* A收到了B的确认后，进入FIN-WAIT-2状态，等待B连接释放报文段。
* 若B已经没有数据发送给A了，则通知应用进程释放；B的释放报文段首部<strong>FIN=1;ACK=1;seq=w;ack=u+1;</strong>B进入LAST-ACK状态，等待A的确认。
* A收到B的释放报文，必须发出确认报文，<strong>ACK=1;seq=u+1;ack=w+1;</strong>,此时A进入TIME-WAIT状态，若B收到确认报文后则进入关闭；现在TCP还没有释放，经过时间等待计时器设置的2MSL(最长报文段寿命，建议设置2分钟，实际设置30秒；2MSL-4分钟，实际1分钟)，A才进入关闭。

> <strong>为什么要经过2MSL的时间</strong>
> 1、确保A发送的最后一个ACK报文能到达B；这个报文有可能丢失，B会重传确认报文，A在2MSL时间内重传一次确认，同时重启2MSL计时器。最后AB都能正常进入关闭状态。
> 2、防止已经失效的请求报文段出现在连接中，经过A最后一个ACK报文后，再经过2MSL时间，使得本次连接中产生的所有报文段都从网络中消失。

### 保活计时器(keepalive timer)

假如客户端与服务端建立了TCP连接，但是由于客户端突然出现故障；服务器不再受到客户端的数据，却要一直等待；因此使用<strong>保活计时器</strong>，服务器每次收到客户端的数据就重新设置保活计时器，时间为2小时；两小时没有收到客户端数据，服务器发送探测报文段，每隔75秒发送一次，一连发送10个探测报文无反应则服务器认为客户端出了故障，关闭这个连接。

### 面试题 [参考](https://juejin.im/post/5e527c58e51d4526c654bf41#heading-13)
* 说说半连接队列和SYN Flood攻击的关系?
> 三次握手前，服务端的状态从CLOSED变为LISTEN，同时创建两个队列：<strong>半连接队列和全连接队列，即SYN队列和ACCEPT队列</strong>  
> 半连接队列  
> 当客户端发送SYN到服务端，服务端收到以后恢复ACK和SYN，状态有LISTEN变为SYN_RCVD，此时这个连接进入SYN队列，也就是半连接队列。  
> 全连接队列  
> 当客户端返回ACK，服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个TCP维护的队列，就是全连接队列。  
> SYN Flood攻击原理  
> SYN Flood属于典型的DOS/DDoS攻击。其攻击原理就是用客户端在短时间内伪造大量不存在的ip地址，并向服务器发送SYN，对于服务器而言，造成的后果：  
> 1.处理大量的SYN包并返回对应的ACK，势必有大量连接出入SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。  
> 2.由于是不存在的IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务器资源。  
> 如何应对SYN Flood攻击  
> 1.增加SYN连接，也就是增加半连接队列容量。  
> 2.减少SYN+ACK重试次数，避免大量的超时重发。  
> 利用SYN Cookie技术，在服务端收到SYN后不立即分配连接资源，而是根据SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候，带上这个Cookie值，服务端验证Cookie合法之后才分配连接资源。  

