

## 锁的粒度
表锁与行锁的区别:
* 锁定粒度-表锁 > 行锁
* 加锁效率-表锁 > 行锁
* 冲突概率-表锁 > 行锁
* 并发性能-表锁 < 行锁

### 共享锁(Share S锁) 行锁
又称读锁，共享锁就是多个事务对同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改；
```sql
# 加锁方式
select * from student where id = 1 LOCK IN SHARE MODE;
# 释放锁
commit/rollback;
```

### 排他锁(X 锁) 行锁
又称为写锁，排他锁不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的锁(共享锁、排他锁)，只有获取了排他锁的事务是可以对数据进行读取和修改。
```sql
# 加锁方式
# 自动
delete / update /insert 默认加上X锁;
# 手动
select * from student where id=1 FOR UPDATE;
```

### 意向共享锁(IS)/意向排他锁(IX) 表锁，一个标志
* 意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，意向共享锁(Intention Shared Lock，简称IS锁)。  
> 表示事务准备给数据行加入共享锁，也就是一个数据行加共享锁必须先取得该表的IS锁。

* 意向排他锁(Intention Exclusion Lock，简称IX锁)；
> 表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。

>> 给一张表加表锁的前提：  
>>>没有任何事务已经锁定表的任意一行数据，需要进行全表扫描。有了意向锁，就相当flag。

# 全局锁
根据加锁范围，可以分成全局锁、表级锁、行锁三大类。  
全局锁顾名思义就是对整个数据库实例加锁。提供一个全局加读锁的方法-Flush tables with read lock(FTWRL),当你只让整个数据库处于只读状态的时候，可以使用这个命令，以下命令会被阻塞：数据更新语句(数据的增删改)、数据定义语句(包括建表、修改表结构等)和更新类事务的提交语句。  
<strong>全局锁的使用场景，做全库逻辑备份</strong>   
mysql自带的mysqldump逻辑备份工具，使用参数-single-transaction，导数据前，启动一个事务，来确保拿到一致性视图。  
一致性读是好，但前提是引擎要支持这个隔离级别。比如myIsam不支持事务的。single-transaction方法只适用于所有表使用事务引擎的库。如果有表使用不支持事务的引擎，则备份只能通过FTWRL方法。   
为什么不使用set global readonly=true的方式，主要原因：  
* 有些系统中，readonly的值用来做其他逻辑，判断一个库是否为主库还是备库。修改global变量的方式影响面更大，不建议使用。
* 异常处理机制有区别。如果执行FTWRL命令之后，由于客户端异常断开，mysql会自动释放全局锁，整个库可以回到正常更新的状态。而将整个库设置成readonly后，如果发生异常，数据库一直会保持readonly状态，导致整个库长时间处于不可写状态，风险较高。  

# 表级锁
表级别锁有两种：一种是表锁，一种是元数据锁(meta data lock,MDL).   
表锁的语法是lock tables ...read/write。可以用unlock tables主动释放锁，也可以在客户端断开时自动释放。lock tables除了会限制别的线程读写外，也会限定本线程的其他行为。  
<strong>另一类表级锁：MDL(meta data lock)。</strong>MDL不需要显示使用，在访问一个表时会自动加上，  
mysql5.6引入MDL，当对一个表做增删查改操作的时候，加MDL读锁；当要对表结构做变更操作时，加MDL写锁。  
读锁之间不互斥，因此可以多个线程同时一张表增删查改。  
读写锁之间、写锁之间是互斥的。用来保证表变更结构操作的安全性。如果有两个线程要给一个表加字段，其中一个要等另一个执行完才能执行。  

事务中的MDL锁，语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。  
如何安全地给小表加字段？  
首先解决长事务，事务不提交一直会占着MDL锁。可以在information_schema库中的Innodb_trx表中，查看当前执行的事务，如果有长事务，考虑先暂停DDL或者kill这个长事务。  
如果是一个热点表，kill未必管用。理想的机制是在alter table语句里面设定等待时间，这个等待的时间里能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后由开发人员或者DBA再通过重试命令重复这个过程。

# 行锁
mysql的行锁在引擎层由各个引擎自己实现。并不是所有引擎都支持行锁，例如myISAM。  
顾名思义，行锁是对数据表中的记录的锁。比如事务A更新了一行，这时候B也要更新同一行，必须等待事务A的操作完才能进行。  
在Innodb事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束才释放。-两阶段锁协议。   
<font color="red">如果事务中需要锁多个行， 把最可能造成锁冲突、最可能影响并发度锁尽量往后放</font>  
## 死锁和死锁检测
当并发系统中不同线程出现资源循环依赖，涉及的线程都在等待别的线程释放资源是，就会导致这个几个线程进入无线等待的状态，称为死锁。  
![死锁](/数据库/img/死锁-1.jpg)  
死锁解决策略：  
* 直接进入等待，直到超时，这个超时通过参数Innodb_lock_wait_timeout来设置。  
* 发起死锁检测，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数Innodb_deadlocak_detect设置为on，表示开启这个逻辑。  

开启死锁检测会导致，每个新来堵住的线程都要判断会不会由于自己的加入导致了死锁，时间复杂度为O(n);例如1000个线程要同时更新同一行，死锁检测级别就是100万量级，会耗费大量CPU资源，却执行不了几个事务。  
热点行更新导致的性能问题如何解决？  
症结在于死锁检测要耗费大量的CPU资源。  
* 一种头痛医头的办法，假如你能保证业务一定不会出现死锁，可以临时把死锁检测关闭。
* 控制并发度，同一行控制同时修改的线程数，死锁检测成本会很低。但是如果连接大量的客户端，峰值并发数也不小。 并发控制要坐在数据库服务端，对于相同行的更新，在进入引擎之前排队，
* 可以考虑将一行改成逻辑上的多行来减少冲突，并发的时候任意选择其中一条记录加锁，可以减少锁等待个数，减少了死锁检测的CPU消耗。需要根据业务逻辑做详细设计。  