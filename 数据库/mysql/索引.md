# 索引

## 索引常见的模型


## InnoDB的索引模型

InnoDB使用B+树索引模型。  
主键列为id，字段k有索引。
```sql
 create table T(
     id int primary key, 
    k int not null, 
    name varchar(16),
    index (k))engine=InnoDB;
```
![](../img/索引-1.png)
根据叶子节点内容：主键索引和非主键索引。  
* 主键索引的叶子节点存的是整行数据。也被称为聚集索引(clustered index).
* 非主键索引的叶子节点存的是主键的值。也称为二级索引(Secondary index).

<strong>基于主键索引和普通索引的查询有什么区别?</strong>  
* 如果是`select * from T where id = 500`主键查询方式，则只需要搜索id这个B+树。
* 如果`select * from T where k = 5`,普通索引方式，需要先搜索K索引树，得到id值500，再到id索引树搜索一次，这过程称为<strong>回表</strong>。

我们尽量使用主键查询。

### 索引维护

### 覆盖索引
如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经"覆盖了"我们的查询需求，我们称为覆盖索引。  
<strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong>

### 最左前缀原则
B+ 树这种索引结构，可以利用索引的"最左前缀"，来定位记录。(name,age)联合索引  
![](../img/索引-2.png)
索引项是按照索引定义里面出现的字段顺序排序的。
<strong>建立联合索引的时候，如何安排索引内的字段顺序，索引复用能力，因为支持最左原则，(a,b)联合索引，不需要再单独在a上建立索引，第一原则是通过调整顺序，减少维护一个索引；如果单独要做b的查询，则同时需要维护(a,b),(b)两个索引；这时考虑空间问题，name字段比age字段大，则创建(name,age)联合索引，(age)单字段索引。</strong>

### 索引下推
如果满足最左前缀原则，可以在索引中定位记录，那么不符合左前缀的部分呢？  
```sql
select * from tuser where name like '张 %' and age=10 and ismale=1;
```
这个语句搜索时，只能用"张",找到第一个满足条件的ID3，在<strong>Mysql5.6</strong>之前，只能从ID3开始一个个回表，找到主键索引上的数据行，比较字段值。在<strong>Mysql5.6</strong>开始，引入了<strong>索引下推</strong>(index condition pushdown)，在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。  
无索引下推
![](../img/索引-3.png)
索引下推
![](../img/索引-4.png)