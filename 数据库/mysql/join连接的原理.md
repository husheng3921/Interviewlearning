# join
## inner join内连接
内连接中on与where子句都是等价的，驱动表与被驱动表是可以互换的，并不会影响查询结果，凡是不符合子句中的记录都会被过滤掉。
## left join （左连接）right join右连接
左连接驱动表是左边的表，右边(被驱动表)不符合条件的记录会缺省NULL显示,驱动表显示全部内容
右连接驱动表是右边的表，左边(被驱动表)不符合条件的记录会缺省NULL显示，
```sql
mysql> SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)

mysql> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
|    1 | a    | NULL | NULL |
+------+------+------+------+
3 rows in set (0.00 sec)

mysql> SELECT * FROM t1 RIGHT JOIN t2 ON t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
| NULL | NULL |    4 | d    |
+------+------+------+------+
3 rows in set (0.00 sec)
```
## 连接的原理

### 嵌套循环连接（Nested-Loop Join)
两表连接，驱动表只会被访问一次，但被驱动表却要被访问好多遍，具体取决于驱动表执行单表查询后的结果集中的记录数。

### 使用索引加快连接速度
如果访问被驱动列表都是全表扫描的话，就得扫描很多次，可以利用索引加快查询速度。
单表中使用主键或者唯一二级索引列的值进行等值查询方式称为const
而被驱动表中使用主键值或唯一二级索引列的值进行等值查询称为eq_ref  

### 基于块的嵌套循环连接（Block Nested-Loop Join)
循环嵌套连接，被驱动表需要被访问很多次，如果数据特别多且不能使用所以，就需要从磁盘上读好几次这个表，I/O 代价太多，需要尽量减少访问被驱动表的次数。  
join buffer就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表的结果集装在join buffer中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中多条记录做匹配，因为匹配是在内存中完成，所以减少了被驱动表的I/O代价。
join buffer可以通过启动参数join_buffer_size进行设置默认大小256KB
