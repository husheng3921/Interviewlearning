# redis 10万+ QPS
### 为什么redis能这么快？
* 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高
* 数据结构简单，对数据操作也简单
* 采用单线程，单线程也能处理高并发请求，
* 使用多路I/O复用模型，非阻塞IO
  
### redis多路I/O复用
redis采用的I/O多路复用函数：epoll/kqueue/evport/select?  
* 因地制宜
* 优先选择时间复杂度O(1)的I/O多路复用函数作为底层实现  
* 以时间复杂度为O(n)的select作为保底
* 基于react设计模式监听I/O事件

## redis的数据类型
### 用户使用的数据类型
* String:最基本的数据类型，二进制安全(SDS简单动态字符串)
* Hash:String元素组成的字典，适合用于存储对象(ziplist和hashtable)
* List:列表,按照String元素插入顺序排序(ziplist和linkedlist)
* Set:String元素组成的无序集合，通过hash表实现，不允许重复(intset整数集合，hashtable哈希表)
* Sorted Set:通过分数来为集合中的成员进行从小到大的排序(skiplist跳跃表和ziplist压缩列表)
* 用于计数的HyperLog，用于支持存储地理位置信息的Geo
### 底层数据类型基础
* 简单动态字符串
* 链表
* 字典
* 跳跃表
* 整数集合
* 压缩列表
* 对象


## Redis持久化
### RDB和AOF的优缺点

|方式|优点|缺点|
|--|--|--|
|RDB|全量数据快照，文件小、恢复快|无法保存最近一次快照之后的数据|
|AOF|可读性高，适合保存增量数据，数据不易丢失|文件体积较大，恢复时间较长|

## RDB-AOF混合持久方式 4.0后


## Redis的同步机制
### 全量同步过程
* Slave 发送Sync命令到master
* Master启动一个后台进程，将redis中的数据快照保存到文件中
* Master将保存数据快照期间接收到的写命令缓存起来
* Master完成写文件操作后，将该文件发送给slave
* 使用新的AOF文件替换掉旧的AOF文件
* Master将这期间收集的增量写命令发送给salve端。

### 增量同步过程
* Master接收到用户的操作指令，判断是否需要传播到Slave
* 将操作记录追加到AOF文件
* 将操作传播到其他Slave：1.对齐主从库；2.往响应缓存写入指令
* 将缓存中的数据发送给slave

## Redis Sentinel(哨兵)
### 解决主从同步Master宕机后的主从切换问题
* 监控：检查主从服务器是否运行正常
* 提醒：通过API向管理员或者其他应用程序发送故障通知
* 自动故障迁移：主从切换

机制类似于Zookeeper

### 流言协议Gossip
在杂乱无章中需求一致：  
* 每个结点都随机地与对方通信，最终所有结点的状态达成一致。
* 种子结点定期随机向其他节点发送节点列表以及需要传播的消息
* 不保证信息一定会传递给所有结点，但是最终会趋于一致
  
## Redis的集群原理
### 如何从海量数据里快速找到所需
* 分片：按照某种规则去划分数据，分散存储在多个节点上
* 常规的按照hash划分无法实现节点的动态增减
* > 一致性哈希算法：对2^32取模，将哈希值空间组成虚拟的圆环，  
* > 将数据key使用相同的hash函数计算出哈希值  
* > 某个节点宕机，会发生数据倾斜
* > 引入虚拟节点解决数据倾斜的问题
无中心协议，获取key的hash
redis-cluster采用去中心化思想，没有中心节点的说法，客户端与redis节点直连，不需要中间代理层，连接任何一个可用节点。
## 如何实现分布式锁

## 如何实现异步队列、消息订阅

## Redis使用
linux下启动客户端:
```shell
./redis-cli # 启动客户端
auth 密码 #密码登录
```
## 参考阅读
[大厂面试！我和面试官之间关于Redis的一场对弈](https://mp.weixin.qq.com/s/DHTPSfmWTZpdTmlytzLz1g)  
