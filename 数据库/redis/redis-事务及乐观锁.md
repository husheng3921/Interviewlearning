# redis-事务及乐观锁

## 事务(multi/exec/discard)
redis中，事务是弱事务，没有隔离级别，事务中的多条命令也是原子性的；事务本质：一组命令的集合，事务中的所有命令都会被序列化，存放在队列中，事务执行过程中，按顺序执行。

### 正常事务执行
redis事务三步走
* 开启事务（multi）
* 命令入队（执行的命令写入队列，先进先出)
* 执行事务(exec)

```shell

127.0.0.1:6379>
127.0.0.1:6379> flushall
OK
127.0.0.1:6379> multi  #开启事物
OK
127.0.0.1:6379> set name wuxl  #命令入队
QUEUED
127.0.0.1:6379> set age 30    #命令入队
QUEUED
127.0.0.1:6379> get name     #命令入队
QUEUED
127.0.0.1:6379> set addr shanghai  #命令入队
QUEUED
127.0.0.1:6379> exec    #执行事物 
1) OK
2) OK
3) "wuxl"
4) OK
127.0.0.1:6379>
```
### 取消事务
discard
```

127.0.0.1:6379>
127.0.0.1:6379> flushall
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set name wuxl
QUEUED
127.0.0.1:6379> set age 30
QUEUED
127.0.0.1:6379> discard   #取消事物
OK
127.0.0.1:6379> get age   #事物中的命令未执行，这里查询不到
(nil)
127.0.0.1:6379>
```
### 事务报错
* 编译错误 
* 运行错误；运行错误后，事务不会回滚，且不影响后续的命令执行，只有出错的命令会执行失败；所以队列中的命令，是不存在原子性的。


## 乐观锁(watch)
### 乐观锁和悲观锁
* 悲观锁：认为并发可能性较大，比较悲观；需要加锁，加锁降低性能
* 乐观锁：认为并发问题的可能性较小，比较乐观，不需要加锁，只需要操作时比较原来的数据是否发生变化，没有变化就修改，有变化就不修改，mysql中version字段，MVCC；redis提供`watch`命令，监控数据修改，是redis乐观锁的实现

### 转账模拟
并发模拟，redis事务没有隔离性会相互影响。

第一步：初始化两个账户的金额，
```shell

127.0.0.1:6379> flushall
OK
127.0.0.1:6379> set acc1 1000   #付钱账户
OK
127.0.0.1:6379> set acc2 0      #收钱账户
OK
127.0.0.1:6379>
```
第二步：使用客户端一，开启watch监听acc1是否发生变化，同时开启事务，命令入队，先不执行事务
```shell

127.0.0.1:6379>
127.0.0.1:6379> watch acc1    # 使用watch监控acc1的账户在执行事物时是否发生变化
OK
127.0.0.1:6379> multi         # 开启事物
OK
127.0.0.1:6379> decrby acc1 100   #模拟付钱
QUEUED
127.0.0.1:6379> incrby acc2 100   #模拟收钱
QUEUED
127.0.0.1:6379> 
```
第三步：使用客户端二，修改acc1账户金额
```shell

127.0.0.1:6379>
127.0.0.1:6379> incrby acc1 1000 # 模拟向acc1的账户再存款1000
(integer) 2000
127.0.0.1:6379> get acc1         # 这是acc1的账户发生变化，有2000  
"2000"
127.0.0.1:6379>
```
第四步：使用客户单一，执行事务
```shell

127.0.0.1:6379> exec            # 执行事物，执行时，会比较acc1是否发生变化，如果变化，就执行失败；如果acc1未变化，就执行成功
(nil) #执行失败
127.0.0.1:6379> get acc1
"2000"
127.0.0.1:6379> get acc2
"0"
127.0.0.1:6379>
```
