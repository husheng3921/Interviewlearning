# 死锁

## 概念
系统中有两个或两个以上的进程无限期地相互等待永远不会发生的条件，也就是说每个进程都在等待该组其他进程中另一个进程的所占资源。
## 死锁原因
* 进程顺序推进不当
* 对互斥资源的分配不当
  
## 产生死锁的四个必要条件
必要条件的意思就是死锁必有下面这个四个条件，缺少任一条件，死锁就不会发生；
* 互斥条件：任何时刻只允许一个进程使用资源  
* 不可剥夺条件：进程已占有资源，不会被强制剥夺
* 保持和等待条件：进程占用部分资源，同时申请更多的资源且不释放占用的资源
* 循环和等待条件：请求的进程形成了循环
  
## 死锁的处理方法

* 忽略死锁的发生
* 检测死锁并恢复：存在环路，取消一个进程；进程阻塞超时，取消该进程
* 谨慎分配资源，避免死锁
* 破坏四个必要条件之一来避免死锁  

## 死锁预防
破坏产生死锁的四个必要条件之一：

* 破坏互斥使用条件：独享设备改为共享设备，假脱机技术
* 破坏不可剥夺条件：资源暂时释放策略，申请新的资源得不到满足，暂时释放已有的资源。
* 破坏保持和等待条件：a.每个进程一次性申请要求的所有资源，仅当所有资源均满足；b.当进程申请资源时，释放自己的资源再申请，当申请成功后再回收刚才的资源。
* 破坏循环等待条件：采用资源有序分配，给资源编号，使用时按升序进行。

## 死锁避免

进程每发出一个系统能满足的资源申请，进行动态检查，并根据结果是否分配资源，产生死锁则不分配。  
<strong>安全状态</strong>:存在一个由系统中所有进程构成的安全序列p1,p2,p3--pn。  
<strong>安全序列</strong>:对于一个进程序列{P1,P2,..Pi...Pn}每个进程Pi,它以后尚需要的资源量Need[i]不超过当前剩余量Available[i]和所有进程Pj(j<i)已分配的资源量Allocation[i]之和,则处于安全。 

### 银行家调度算法

```dotnetcli
Work: Array[1...n] 资源剩余量  
Finsh: Array[1...n] 进程完成状态 
安全性检查步骤：
(1)Work = Available;//当前可用资源
    Finsh = false;//所有进程都为未完成
(2)寻找满足条件的i:
    a. Finsh[i] = false;
    b. Need[i] <= Work;
    存在走(3),不存在走(4)
(3)Work = Work + Allocation[i];//收回i进程的资源
    Finsh[i] = true;
(4)所有i，均满足Finsh[i] = true ,则系统处于安全，否则不安全，产生死锁。

```
总结:查找进程，该进程所申请资源是否小于当前可用量，存在则标记该进程结束，同时收回所分配的资源，更新当前可用资源，如果都能找到则安全，否则不安全，产生斯诺。

## 参考
《操作系统设计与实现》