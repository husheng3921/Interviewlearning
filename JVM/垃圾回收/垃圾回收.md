# 垃圾回收
垃圾回收的主要目的是：清除不再使用的对象，自动释放内存。  
GC是如何判断对象是否可以被回收？引入GCRoots，如果一个对象与GCRoots之间没有直接或间接的引用关系，比如某个失去任何引用的对象，或者两个互相环岛状循环引用的对象，都可以判定死缓，进行回收。  
GCRoots：  
类静态属性中引用的对象、常量引用的对象、虚拟机栈中引用的对象、虚拟机栈中引用的对象、本地方法栈中引用的对象等。  

## 垃圾回收算法

|类型|核心思路|缺点|优点|其他|
|--|--|--|--|--|
|标记-清除|从GCroots出发，依次标记引用关系的对象，最后没有被标记的对象清除。|产生大量的空间碎片，分配一个较大的连续空间会导致FGC| | |
|标记-整理|类似于磁盘整理，从GCRoots出发标记存活的对象，然后将存活的对象整理到内存空间的一端，形成连续已使用的空间，最后把已使用空间之外的部分全部清理掉，不会产生碎片| | | |
|Mark-Copy|为了并行标记和整理将空间分为两块，每次只激活其中一块，垃圾回收时，只需要把存活的对象复制到另一个未激活的空间上，同时将未激活的空间标记已激活，将已激活的空间标记为未激活，然后清除原空间中的对象。堆内分为较大的Eden和两块较小的Survivor，每次只是用Eden和Survivor区的一块。| |减少内存空间的浪费| YGC算法进行新生代回收|



## 垃圾回收器