# 对象实例化

## 从Object ref = new Object()分析
```java
  stack=2, locals=2, args_size=1
         0: new           #2                  // class java/lang/Object
         3: dup
         4: invokespecial #1                  // Method java/lang/Object."<init>":()V
```
* NEW :如果找不到Class对象，则进行类加载。加载成功后，在堆中进行内存分配，所有属性值都要分配内存。分配完毕之后，进行零初始；分配时，引用是一个变量占据4字节。将指向实例对象的引用压入虚拟机栈顶。
* DUP：在栈顶复制该引用变量，此时栈顶有两个指向堆内实例的引用变量。如果`<init>`有参数，则还要把参数压入操作栈中。两个引用变量一个压至底下的引用用于赋值，或者保存局部变量；另一个栈顶的引用变量作为句柄调用相关方法。
* INVOKESPECIAL：调用对象实例方法，通过栈顶的引用变量调用`<init>`。`<clinit>是类初始化执行的方法，而<init>是对象初始化执行的方法`。

## 执行步骤分析
* 确认类元信息是否存在。当JVM收到new指令时，在metspace查需要创建的类元信息是否存在，不存在则双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key查找对应的.class文件，没有则抛出异常，有则进行加载生成对应的CLass类对象。
* 分配对象内存，计算对象占用的空间，实例成员变量是引用变量，只需要分配引用变量空间4字节。分配内存时，需要进行同步操作，比如用CAS(compare and swap)失败重试、区域加锁等方式保证分配操作的原子性。
* 设定默认值，成员变量都需设定默认值，各种不同形式的零值。
* 设置对象头，设置对象的哈希码、GC信息、锁信息、对象所属的类元信息等。
* 执行init方法，初始化成员变量，执行实例化代码块，调用类构造方法，并把堆内对象的首地址赋给引用变量。